#pragma once

#include "math_types.h"
#include <string>

namespace kite_sim {

/**
 * @brief Physical and mechanical properties of the tether
 * 
 * Contains all parameters needed to model tether behavior including
 * geometric, material, and aerodynamic properties.
 */
class TetherProperties {
public:
    // Constructors
    TetherProperties();
    TetherProperties(double length, double mass_per_length, double diameter,
                    double elastic_modulus = 0.0, double drag_coefficient = 1.2);
    
    // Copy constructor and assignment
    TetherProperties(const TetherProperties& other) = default;
    TetherProperties& operator=(const TetherProperties& other) = default;
    
    // Move constructor and assignment
    TetherProperties(TetherProperties&& other) noexcept = default;
    TetherProperties& operator=(TetherProperties&& other) noexcept = default;
    
    // Destructor
    ~TetherProperties() = default;
    
    // Basic properties
    double length() const { return length_; }
    void setLength(double length) { length_ = length; }
    
    double massPerLength() const { return mass_per_length_; }
    void setMassPerLength(double mass_per_length) { mass_per_length_ = mass_per_length; }
    
    double diameter() const { return diameter_; }
    void setDiameter(double diameter) { diameter_ = diameter; }
    
    // Elastic properties
    double elasticModulus() const { return elastic_modulus_; }
    void setElasticModulus(double modulus) { elastic_modulus_ = modulus; }
    
    bool isElastic() const { return elastic_modulus_ > 0.0; }
    
    // Aerodynamic properties
    double dragCoefficient() const { return drag_coefficient_; }
    void setDragCoefficient(double cd) { drag_coefficient_ = cd; }
    
    // Attachment points
    Vector3 kiteAttachmentPoint() const { return kite_attachment_; }
    void setKiteAttachmentPoint(const Vector3& point) { kite_attachment_ = point; }
    
    Vector3 groundAttachmentPoint() const { return ground_attachment_; }
    void setGroundAttachmentPoint(const Vector3& point) { ground_attachment_ = point; }
    
    // Derived properties
    double totalMass() const { return length_ * mass_per_length_; }
    double crossSectionalArea() const;
    double elasticConstant() const;
    
    // Validation
    bool isValid() const;
    std::vector<std::string> getValidationErrors() const;
    
    // Serialization
    std::string toJson() const;
    bool fromJson(const std::string& json_str);
    
    // Comparison operators
    bool operator==(const TetherProperties& other) const;
    bool operator!=(const TetherProperties& other) const;
    
    // Default configurations
    static TetherProperties createDefaultTether();
    static TetherProperties createElasticTether();
    static TetherProperties createInelasticTether();

private:
    double length_;              // Tether length (m)
    double mass_per_length_;     // Mass per unit length (kg/m)
    double diameter_;            // Tether diameter (m)
    double elastic_modulus_;     // Elastic modulus (Pa), 0 for inelastic
    double drag_coefficient_;    // Drag coefficient for crosswind forces
    
    Vector3 kite_attachment_;    // Attachment point on kite (body coordinates)
    Vector3 ground_attachment_;  // Ground anchor point (world coordinates)
};

/**
 * @brief Forces and moments generated by the tether
 */
struct TetherForces {
    Vector3 force;          // Force vector in world coordinates (N)
    Vector3 moment;         // Moment vector about kite CG in body coordinates (N⋅m)
    double tension;         // Tether tension (N)
    double current_length;  // Current tether length (m)
    bool constraint_active; // Whether length constraint is active
    
    TetherForces();
    TetherForces(const Vector3& f, const Vector3& m, double t, double len, bool active = true);
    
    // Utility
    bool isValid() const;
    void reset();
};

/**
 * @brief Tether mechanics model for force and constraint calculation
 * 
 * Supports both elastic and inelastic tether models with proper constraint
 * handling and aerodynamic drag forces.
 */
class TetherModel {
public:
    // Constructors
    TetherModel();
    explicit TetherModel(const TetherProperties& properties);
    
    // Copy constructor and assignment
    TetherModel(const TetherModel& other) = default;
    TetherModel& operator=(const TetherModel& other) = default;
    
    // Move constructor and assignment
    TetherModel(TetherModel&& other) noexcept = default;
    TetherModel& operator=(TetherModel&& other) noexcept = default;
    
    // Destructor
    ~TetherModel() = default;
    
    // Properties access
    TetherProperties& properties() { return properties_; }
    const TetherProperties& properties() const { return properties_; }
    void setProperties(const TetherProperties& props) { properties_ = props; }
    
    // Force calculation
    TetherForces calculateTetherForces(const Vector3& kite_position,
                                      const Quaternion& kite_attitude,
                                      const Vector3& kite_velocity,
                                      const Vector3& wind_velocity = Vector3(0, 0, 0)) const;
    
    // Constraint checking
    bool checkConstraints(const Vector3& kite_position) const;
    double getCurrentLength(const Vector3& kite_position) const;
    double getConstraintViolation(const Vector3& kite_position) const;
    
    // Tether state queries
    bool isTetherTaut(const Vector3& kite_position) const;
    Vector3 getTetherDirection(const Vector3& kite_position) const;
    Vector3 getTetherVector(const Vector3& kite_position) const;
    
    // Environmental effects
    void setAirDensity(double density) { air_density_ = density; }
    double getAirDensity() const { return air_density_; }
    
    // Validation
    bool isValid() const;
    
    // Configuration
    static TetherModel createElasticModel(double length, double mass_per_length, 
                                         double diameter, double elastic_modulus);
    static TetherModel createInelasticModel(double length, double mass_per_length, 
                                           double diameter);

private:
    TetherProperties properties_;
    double air_density_;  // Air density for drag calculations (kg/m³)
    
    // Internal calculation methods
    TetherForces calculateElasticForces(const Vector3& kite_position,
                                       const Quaternion& kite_attitude,
                                       const Vector3& kite_velocity,
                                       const Vector3& wind_velocity) const;
    
    TetherForces calculateInelasticForces(const Vector3& kite_position,
                                         const Quaternion& kite_attitude,
                                         const Vector3& kite_velocity,
                                         const Vector3& wind_velocity) const;
    
    Vector3 calculateDragForce(const Vector3& kite_position,
                              const Vector3& kite_velocity,
                              const Vector3& wind_velocity) const;
    
    Vector3 calculateMomentArm(const Vector3& kite_position,
                              const Quaternion& kite_attitude) const;
    
    // Validation helpers
    bool arePropertiesValid() const;
    bool isPositionValid(const Vector3& position) const;
};

} // namespace kite_sim